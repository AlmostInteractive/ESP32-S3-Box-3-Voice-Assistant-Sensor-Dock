# Search for "TODO" and adjust as necessary
substitutions:
  name: s3box3-voice-asst-sd
  friendly_name: S3 Box 3 Voice Assistant SD
  micro_wake_word_model: hey_jarvis  # options: okay_nabu, hey_jarvis, alexa
  noise_suppression_level: '3'

  # ----- TODO: Fill these in with your device's values
  ota_password: "XXX"
  encryption_key: "XXX"

  # ----- TODO: Fill these in with the path to your local sound files.  Use HTTP as HTTPS can induce 2+ seconds of lag when playing.
  wakeword_sound: 'http://192.168.100.10:8123/local/sounds/wakeword.mp3'
  success_sound: 'http://192.168.100.10:8123/local/sounds/success.mp3'
  error_sound: 'http://192.168.100.10:8123/local/sounds/error.mp3'

  # ----- don't mess with anything below this line (except, optionally, the TODOs) -----
  VERSION: '1.3.1'
  ALLOWED_CHARACTERS: " !#%\"'()+,-./0123456789:;<>?@ABCDEFGHIJKLMNOPQRSTUVWYZ[]_abcdefghijklmnopqrstuvwxyz{|}°²³µ¿ÁÂÄÅÉÖÚßàáâãäåæçèéêëìíîðñòóôõöøùúûüýþāăąćčďĐđēėęěğĮįıļľŁłńňőřśšťũūůűųźŻżŽžơưșțΆΈΌΐΑΒΓΔΕΖΗΘΚΜΝΠΡΣΤΥΦάέήίαβγδεζηθικλμνξοπρςστυφχψωϊόύώАБВГДЕЖЗИКЛМНОПРСТУХЦЧШЪЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюяёђєіїјљњћ"
  
  VA_IN_HOME_ASSISTANT: "In Home Assistant"
  VA_ON_DEVICE: "On device"

  VA_SPEAKER_SPEECH: "Speech"
  VA_SPEAKER_BEEP: "Beep"
  VA_SPEAKER_MUTE: "Mute"

  APP_STATE_LOADING: '0'
  APP_STATE_STATUS: '1'
  APP_STATE_IR_LEARNING: '2'
  APP_STATE_IR_BLAST: '3'
  APP_STATE_VA: '4'
  APP_STATE_SETTINGS: '5'
  APP_STATE_SCREEN_SAVER: '6'
  APP_STATE_TOUCHSCREEN_ERROR: '7'
  NUM_PAGES: '6'

  VA_STATE_NOT_READY: '1'
  VA_STATE_IDLE: '2'
  VA_STATE_LISTENING: '3'
  VA_STATE_THINKING: '4'
  VA_STATE_REPLYING: '5'
  VA_STATE_ERROR: '6'
  VA_STATE_MUTED: '7'

esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  min_version: 2025.2.0
  name_add_mac_suffix: true
  on_boot:
    priority: 600
    then:
      - light.turn_on: 
          id: led
          brightness: 100%
      - display.page.show: loading_page
      - component.update: s3_box_lcd
  project:
    name: "AlmostInteractive.VoiceAssistantSensorDock"
    version: ${VERSION}

esp32:
  board: esp32s3box
  flash_size: 16MB
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: "y"
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"

psram:
  mode: octal
  speed: 80MHz

ota:
  - platform: esphome
    password: ${ota_password}

logger:
  hardware_uart: USB_SERIAL_JTAG
  level: DEBUG
  logs:
    micro_wake_word: WARN
    sensor: WARN
    binary_sensor: WARN
    esp-idf: WARN
    esp_adf_pipeline: WARN
    esp_audio_processors: WARN
    esp_audio_sources: WARN

api:
  id: my_api
  # TODO: uncomment to use encryption. encryption:
  # TODO: uncomment to use encryption.   key: ${encryption_key}
  on_client_connected:
    - script.execute: check_touchscreen_failure
    - component.update: s3_box_lcd
  on_client_disconnected:
    - component.update: s3_box_lcd

captive_portal:

wifi:
  # TODO: uncomment to use stored secrets. ssid: !secret wifi_ssid
  # TODO: uncomment to use stored secrets. password: !secret wifi_password
  ap:
    ssid: ${name}
    password: s3box123
  on_connect:
    - script.execute: check_touchscreen_failure
    - script.wait: check_touchscreen_failure
    - if:
        condition:
          - lambda: return id(touchscreen_error_counter) < 0;
        then:
        - script.execute: box_initialize
        - script.wait: box_initialize
        - script.execute:
            id: change_app_state
            nextState: ${APP_STATE_STATUS}
  on_disconnect:
    - component.update: s3_box_lcd

time:
  - platform: homeassistant
    id: ha_time

output:
  - platform: ledc
    pin: GPIO47
    id: backlight_output

light:
  - platform: monochromatic
    id: led
    name: 'LCD Screen'
    icon: 'mdi:television'
    entity_category: config
    output: backlight_output
    restore_mode: RESTORE_DEFAULT_ON
    default_transition_length: 500ms

spi:
  - id: spi_bus
    clk_pin: 7
    mosi_pin: 6

i2c:
  - id: bus_a
    sda: GPIO08
    scl: GPIO18
    scan: false
    sda_pullup_enabled: true
    scl_pullup_enabled: true
    frequency: 100kHz

  - id: bus_b
    sda: GPIO41
    scl: GPIO40
    scan: false
    sda_pullup_enabled: true
    scl_pullup_enabled: true
    frequency: 50kHz

i2s_audio:
  - id: i2s_audio_bus
    i2s_lrclk_pin: GPIO45
    i2s_bclk_pin: GPIO17
    i2s_mclk_pin: GPIO2

audio_adc:
  - id: es7210_adc
    platform: es7210
    i2c_id: bus_a
    bits_per_sample: 16bit
    sample_rate: 16000

audio_dac:
  - id: es8311_dac
    platform: es8311
    i2c_id: bus_a
    bits_per_sample: 16bit
    sample_rate: 48000

microphone:
  - platform: i2s_audio
    id: box_mic
    sample_rate: 16000
    i2s_din_pin: GPIO16
    bits_per_sample: 16bit
    adc_type: external

speaker:
  - platform: i2s_audio
    id: box_speaker
    i2s_dout_pin: GPIO15
    dac_type: external
    sample_rate: 48000
    bits_per_sample: 16bit
    channel: left
    audio_dac: es8311_dac
    buffer_duration: 100ms

media_player:
  - id: speaker_media_player
    platform: speaker
    name: "S3 Box 3 Media Player"
    announcement_pipeline:
      speaker: box_speaker
      format: FLAC
      sample_rate: 48000
      num_channels: 1  # S3 Box only has one output channel
    on_state:
      - lambda: ESP_LOGD("media_player", "on_state");
    on_play:
      - lambda: ESP_LOGD("media_player", "on_play");
    on_pause:
      - lambda: ESP_LOGD("media_player", "on_pause");
    on_idle:
      - lambda: ESP_LOGD("media_player", "on_idle");
    on_announcement:
      - lambda: ESP_LOGD("media_player", "on_announcement");

micro_wake_word:
  models:
    - ${micro_wake_word_model}
  on_wake_word_detected:
    - if:
        condition:
          lambda: return id(mem_va_speaker_mode).state != "${VA_SPEAKER_MUTE}";
        then:
          - media_player.play_media: ${wakeword_sound}
          - wait_until:
              condition:
                not:
                  media_player.is_idle
              timeout: 2sec
          - wait_until:
              condition:
                media_player.is_idle
              timeout: 2sec
    - if:
        condition:
          - lambda: return id(app_state) == ${APP_STATE_SCREEN_SAVER};
        then:
          - script.execute: 
              id: change_app_state
              nextState: ${APP_STATE_STATUS}
    - voice_assistant.start:
        wake_word: !lambda return wake_word;

voice_assistant:
  id: va
  microphone: box_mic
  media_player: speaker_media_player
  noise_suppression_level: ${noise_suppression_level}
  auto_gain: 31dBFS
  volume_multiplier: 4.0
  on_client_connected:
    - lambda: ESP_LOGD("voice_assistant_on", "on_client_connected");
    - if:
        condition:
          lambda: return id(mem_wake_word_engine_location).state == "${VA_IN_HOME_ASSISTANT}";
        then:
          - lambda: id(va).set_use_wake_word(true);
          - voice_assistant.start_continuous
        else:
          - micro_wake_word.start
    - script.execute:
        id: change_va_state
        nextState: ${VA_STATE_IDLE}
    - lambda: id(va_state) = ${VA_STATE_IDLE};
  on_client_disconnected:
    - lambda: ESP_LOGD("voice_assistant_on", "on_client_disconnected");
    - if:
        condition:
          lambda: return id(mem_wake_word_engine_location).state == "${VA_IN_HOME_ASSISTANT}";
        then:
          - lambda: id(va).set_use_wake_word(false);
        else:
          - micro_wake_word.stop
    - voice_assistant.stop
    - script.execute:
        id: change_va_state
        nextState: ${VA_STATE_NOT_READY}
  on_wake_word_detected:
    - lambda: ESP_LOGD("voice_assistant_on", "on_wake_word_detected");
    - text_sensor.template.publish:
        id: va_request
        state: ""
    - text_sensor.template.publish:
        id: va_response
        state: ""
  on_listening:
    - lambda: ESP_LOGD("voice_assistant_on", "on_listening");
    - script.execute:
        id: change_va_state
        nextState: ${VA_STATE_LISTENING}
  on_stt_vad_start:
    - lambda: ESP_LOGD("voice_assistant_on", "on_stt_vad_start");
  on_stt_vad_end:
    - lambda: ESP_LOGD("voice_assistant_on", "on_stt_vad_end");
    - script.execute:
        id: change_va_state
        nextState: ${VA_STATE_THINKING}
  on_error:
    - lambda: ESP_LOGD("voice_assistant_on", "on_error");
    - if:
        condition:
          - lambda: return id(va_state) != ${VA_STATE_NOT_READY};
        then:
          - script.execute:
              id: change_va_state
              nextState: ${VA_STATE_ERROR}
          - text_sensor.template.publish:
              id: va_response
              state: !lambda return message;
          - if:
              condition:
                lambda: return id(mem_va_speaker_mode).state == "${VA_SPEAKER_BEEP}";
              then:
                - media_player.play_media: ${error_sound}
                - wait_until:
                    condition:
                      media_player.is_idle
                    timeout: 2sec
          #- delay: 3s
          - script.execute:
              id: change_va_state
              nextState: ${VA_STATE_IDLE}
  on_stt_end:
    - lambda: ESP_LOGD("voice_assistant_on", "on_stt_end");
    - text_sensor.template.publish:
        id: va_request
        state: !lambda return x;
    - component.update: s3_box_lcd
  on_tts_start:
    - lambda: ESP_LOGD("voice_assistant_on", "on_tts_start");
    - text_sensor.template.publish:
        id: va_response
        state: !lambda return x;
    - script.execute:
        id: change_va_state
        nextState: ${VA_STATE_REPLYING}
    - if:
        condition:
          - lambda: return id(mem_va_speaker_mode).state != "${VA_SPEAKER_SPEECH}";
        then:
          - wait_until:
              condition:
                not:
                  media_player.is_idle
              timeout: 5sec
          - media_player.stop:
              announcement: true
          - wait_until:
              condition:
                media_player.is_idle
              timeout: 1sec
          - if:
              condition:
                lambda: return id(mem_va_speaker_mode).state == "${VA_SPEAKER_BEEP}";
              then:
                - media_player.play_media: !lambda if(x.rfind("Sorry", 0) == 0) return "${error_sound}"; return "${success_sound}";
                - wait_until:
                    condition:
                      media_player.is_idle
                    timeout: 2sec
  on_end:
    - lambda: ESP_LOGD("voice_assistant_on", "on_end");
    - if:
        condition:
          - lambda: return id(mem_wake_word_engine_location).state == "${VA_ON_DEVICE}";
        then:
          - wait_until:
              condition:
                not:
                  voice_assistant.is_running
              timeout: !lambda 'return id(mem_va_speaker_mode).state != "${VA_SPEAKER_SPEECH}" ? 500 : 180000;' #ms
          - micro_wake_word.start
    - script.execute:
        id: change_va_state
        nextState: ${VA_STATE_IDLE}

  on_intent_start:
    - lambda: ESP_LOGD("voice_assistant_on", "on_intent_start");
  on_intent_end:
    - lambda: ESP_LOGD("voice_assistant_on", "on_intent_end");
  on_start:
    - lambda: ESP_LOGD("voice_assistant_on", "on_start");
  on_tts_end:
    - lambda: ESP_LOGD("voice_assistant_on", "on_tts_end");
  on_idle:
    - lambda: ESP_LOGD("voice_assistant_on", "on_idle");
  on_timer_started:
    - lambda: ESP_LOGD("voice_assistant_on", "on_timer_started");
  on_timer_finished:
    - lambda: ESP_LOGD("voice_assistant_on", "on_timer_finished");
  on_timer_cancelled:
    - lambda: ESP_LOGD("voice_assistant_on", "on_timer_cancelled");
  on_timer_updated:
    - lambda: ESP_LOGD("voice_assistant_on", "on_timer_updated");

touchscreen:
  platform: gt911
  i2c_id: bus_a
  id: gt911_touchscreen
  interrupt_pin: GPIO3

switch:
  - id: enable_ir
    platform: gpio
    name: "IR Power"
    icon: 'mdi:led-variant-on'
    entity_category: config
    restore_mode: RESTORE_DEFAULT_ON
    pin:
      number: GPIO44
      inverted: true
    on_turn_on: 
      then:
        - component.update: s3_box_lcd
    on_turn_off: 
      then:
        - component.update: s3_box_lcd

select:
  - id: mem_wake_word_engine_location
    platform: template
    entity_category: config
    name: Wake word engine location
    optimistic: true
    restore_value: true
    options:
      - ${VA_IN_HOME_ASSISTANT}
      - ${VA_ON_DEVICE}
    initial_option: ${VA_IN_HOME_ASSISTANT}
    on_value:
      - if:
          condition:
            lambda: return x == "${VA_IN_HOME_ASSISTANT}";
          then:
            - micro_wake_word.stop
            - delay: 500ms
            - lambda: id(va).set_use_wake_word(true);
            - voice_assistant.start_continuous
            - text_sensor.template.publish:
                id: wakeword_location
                state: !lambda 'return "Home Assistant";'
            - component.update: s3_box_lcd
          else:
            - text_sensor.template.publish:
                id: wakeword_location
                state: !lambda 'return "On Device";'
            - lambda: id(va).set_use_wake_word(false);
            - voice_assistant.stop
            - delay: 500ms
            - micro_wake_word.start
            - component.update: s3_box_lcd
  - id: mem_va_speaker_mode
    platform: template
    entity_category: config
    name: VA Speaker Mode
    optimistic: true
    restore_value: true
    options:
      - ${VA_SPEAKER_SPEECH}
      - ${VA_SPEAKER_BEEP}
      - ${VA_SPEAKER_MUTE}
    on_value:
      - delay: 250ms
      - component.update: s3_box_lcd

sensor:
  - platform: aht10 
    i2c_id: bus_b
    variant: AHT20
    temperature:
      name: "Temperature"
      id: s3temp
    humidity:
      name: "Humidity"
    update_interval: 60s

  - platform: adc
    pin: GPIO10
    name: "Battery voltage"
    id: battery_voltage
    unit_of_measurement: "V"
    accuracy_decimals: 1
    device_class: "voltage"
    entity_category: "diagnostic"
    disabled_by_default: true
    update_interval: 30s
    attenuation: auto
    filters:
      - multiply: 4.11

  - platform: copy
    id: battery_percent
    source_id: battery_voltage
    name: "Battery level"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    device_class: "battery"
    entity_category: "diagnostic"
    filters:
      - lambda: return (x - 2.7) / (4.2 - 2.7) * 100;
      - clamp:
          min_value: 0
          max_value: 100

text_sensor:
  - platform: wifi_info
    ip_address:
      name: ESP IP Address
      address_0:
        name: ESP IP Address 0
      id: ip_addr
  - id: wakeword_location
    platform: template
  - id: va_request
    platform: template
  - id: va_response
    platform: template

number:
  - id: mem_settings_sleep_delay
    platform: template
    name: "Sleep Delay"
    icon: 'mdi:sleep'
    entity_category: config
    unit_of_measurement: 'secs'
    optimistic: true
    restore_value: true
    initial_value: 30
    step: 1
    min_value: 1
    max_value: 999999

font:
  - file: "gfonts://Roboto@500"
    id: font_small
    size: 14
    glyphs: ${ALLOWED_CHARACTERS}
  - file: "gfonts://Roboto@500"
    id: font_medium
    size: 24
    glyphs: ${ALLOWED_CHARACTERS}
  - file: "gfonts://Roboto@500"
    id: font_large
    size: 40
    glyphs: ${ALLOWED_CHARACTERS}
  - file: "gfonts://Roboto@500"
    id: font_extra_large
    size: 60
    glyphs: [Z]
  - file: "https://github.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/raw/master/fonts/materialdesignicons-webfont.ttf"
    id: font_icon_tiny
    size: 30
    glyphs: [
      "\U000F009A",#bell
      "\U000F009C",#bell-outline
      "\U000F00AD",#block-helper
      "\U000F01F2",#emoticon-outline
      "\U000F0375",#minus-box
      "\U000F0416",#plus-box
    ]
  - file: "https://github.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/raw/master/fonts/materialdesignicons-webfont.ttf"
    id: font_icon_small
    size: 45
    glyphs: [
      "\U000F0079",#battery 100%
      "\U000F0082",#battery 90%
      "\U000F0081",#battery 80%
      "\U000F0080",#battery 70%
      "\U000F007F",#battery 60%
      "\U000F007E",#battery 50%
      "\U000F007D",#battery 40%
      "\U000F007C",#battery 30%
      "\U000F007B",#battery 20%
      "\U000F007A",#battery 10%
      "\U000F10CD",#battery warning
      "\U000F050F",#temp sensor
      "\U000F16BD",#wifi connected
      "\U000F16BC",#wifi disconnected
      "\U000F07D0",#api connected
      "\U000F12A8",#touch button
      "\U000F0EBA",#stats
      "\U000F087B",#api disconnected
      "\U000F057E",#speaker on
      "\U000F0581",#speaker off
      "\U000F0493",#settings cog
      "\U000F06E8",#light bulb illuminated
      "\U000F0335",#light bulb off
      "\U000F0A19",#toggle off
      "\U000F0521",#toggle on
      "\U000F032E",#led-variant-off
      "\U000F0330",#led-variant-outline
      "\U000F004F",#arrow-left-bold-circle
      "\U000F0056",#arrow-right-bold-circle
      "\U000F0375",#minus-box
      "\U000F0416",#plus-box
      "\U000F009A",#bell
      "\U000F00AD",#block-helper
      "\U000F01F2",#emoticon-outline
      ]
  - file: "https://github.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/raw/master/fonts/materialdesignicons-webfont.ttf"
    id: font_icon_large
    size: 65
    glyphs: [
      "\U000F004F",#arrow-left-bold-circle
      "\U000F0056",#arrow-right-bold-circle
      ]

image:
  - file: "https://raw.githubusercontent.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/master/images/notready.png"
    id: notready_img
    type: RGB
    transparency: alpha_channel
  - file: "https://raw.githubusercontent.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/master/images/error.png"
    id: error_img
    type: RGB
    transparency: alpha_channel
  - file: "https://raw.githubusercontent.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/master/images/idle.png"
    id: idle_img
    type: RGB
    transparency: alpha_channel
  - file: "https://raw.githubusercontent.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/master/images/listening.png"
    id: listening_img
    type: RGB
    transparency: alpha_channel
  - file: "https://raw.githubusercontent.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/master/images/thinking.png"
    id: thinking_img
    type: RGB
    transparency: alpha_channel
  - file: "https://raw.githubusercontent.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/master/images/replying.png"
    id: replying_img
    type: RGB
    transparency: alpha_channel
  - file: "https://raw.githubusercontent.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/master/images/loading.png"
    id: loading_img
    type: RGB
    transparency: alpha_channel

color:
  - id: green
    hex: '75D15F'
  - id: red
    hex: 'FF3131'
  - id: blue
    hex: '47B7E9'
  - id: blue_light
    hex: 'CFE2F3'
  - id: blue_dark
    hex: '085296'
  - id: amber
    hex: 'FBAB35'
  - id: lime
    hex: '20FC30'
  - id: pink
    hex: 'D92BBC'
  - id: yellow
    hex: 'FFC000'
  - id: black
    hex: '000000'
  - id: white
    hex: 'ffffff'
  - id: purple
    hex: '73264D'
  - id: grey_dark
    hex: '202020'

globals:
  # saved to flash
  - id: mem_ir_code_1
    type: int[256]
    restore_value: true
  - id: mem_ir_code_2
    type: int[256]
    restore_value: true
  - id: mem_ir_code_3
    type: int[256]
    restore_value: true
  - id: mem_ir_code_4
    type: int[256]
    restore_value: true
  # saved in ram
  - id: app_state
    type: int
    restore_value: false
    initial_value: ${APP_STATE_LOADING}
  - id: wake_app_state
    type: int
    restore_value: false
  - id: nav_lock
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: ir_memory_button_selected
    type: int
    restore_value: false
    initial_value: '-1'
  - id: ir_memory_button_codes
    type: std::vector<std::string>
    restore_value: false
  - id: ir_learning_state
    type: int
    restore_value: false
    initial_value: '0'    # 0 = pick a button, 1 = button picked, waiting to turn on, 2 = waiting for control signal, 3 = waiting to turn on, 4 = waiting for control signal
  - id: ir_learning_step
    type: int
    restore_value: false
    initial_value: '0'    # 0 = just started, 1 - 2 = recordings to make
  - id: ir_memory_last_received
    type: int
    restore_value: false
    initial_value: '0'
  - id: ir_memory_recording_codes
    type: std::vector<std::string>
    restore_value: false
  - id: ir_memory_recorded_codes
    type: std::vector<std::vector<std::string>>
    restore_value: false
  - id: radar_last_seen
    type: int
    restore_value: false
    initial_value: '-1'
  - id: va_state
    type: int
    restore_value: false
    initial_value: ${VA_STATE_NOT_READY}
  - id: mute_error
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: touchscreen_error_counter
    type: int
    restore_value: false
    initial_value: '-1'
  - id: ignore_touchscreen_error
    type: bool
    restore_value: false
    initial_value: 'false'

script:
  - id: box_initialize
    then:
      - lambda: |-
          id(ir_memory_button_codes).resize(4, "");

          int* codeArray;
          int length;
          std::string hexStr;
          char buffer[5];
          int* data;

          for (int i = 0; i < 4; i++) {
            switch (i) {
              case 0:
                codeArray = id(mem_ir_code_1);
                break;
              case 1:
                codeArray = id(mem_ir_code_2);
                break;
              case 2:
                codeArray = id(mem_ir_code_3);
                break;
              case 3:
                codeArray = id(mem_ir_code_4);
                break;
            }
          
            length = codeArray[0];
            if (length <= 0) {
              continue;
            }

            hexStr.clear();
            data = codeArray + 1;
            for (int i = 0; i < length; i++) {
              snprintf(buffer, 5, "%04X", data[i]);
              hexStr += buffer;
              if (i != length - 1) {
                hexStr += " ";
              }
            }

            id(ir_memory_button_codes)[i] = hexStr;
          }
  - id: change_app_state
    parameters:
      nextState: int
    then:
      - lambda: |-
          id(app_state) = nextState;
          switch (nextState) {
            case ${APP_STATE_LOADING}:
              id(s3_box_lcd).show_page(id(loading_page));
              break;
            case ${APP_STATE_STATUS}:
              id(s3_box_lcd).show_page(id(status_page));
              break;
            case ${APP_STATE_IR_LEARNING}:
              id(s3_box_lcd).show_page(id(ir_learn_page));
              break;
            case ${APP_STATE_IR_BLAST}:
              id(s3_box_lcd).show_page(id(ir_blast_page));
              break;
            case ${APP_STATE_VA}:
              id(s3_box_lcd).show_page(id(voice_assistant_page));
              break;
            case ${APP_STATE_SETTINGS}:
              id(s3_box_lcd).show_page(id(settings_page));
              break;
            case ${APP_STATE_SCREEN_SAVER}:
              id(s3_box_lcd).show_page(id(screen_saver_page));
              break;
            case ${APP_STATE_TOUCHSCREEN_ERROR}:
              id(nav_lock) = true;
              id(touchscreen_error_counter) = 10;
              id(s3_box_lcd).show_page(id(touchscreen_error_page));
              break;
            default:
              ESP_LOGE("change_app_state", "Unknown state: %d", nextState);
          }
      - component.update: s3_box_lcd
  - id: change_va_state
    parameters:
      nextState: int
    then:
      - lambda: ESP_LOGD("change_va_state", "%d", nextState);
      - lambda: id(va_state) = nextState;
      - component.update: s3_box_lcd
  - id: save_ir_button
    parameters:
      buttonIndex: int
      hexString: std::string
    then:
      - lambda: |-
          int arrayIndex = 1; // Start from 1 because the first element will store the count
          int intValue = 0;
          int hexDigitsInInt = 0;
          int* outputArray;
          
          switch (buttonIndex) {
            case 0:
              outputArray = id(mem_ir_code_1);
              break;
            case 1:
              outputArray = id(mem_ir_code_2);
              break;
            case 2:
              outputArray = id(mem_ir_code_3);
              break;
            case 3:
              outputArray = id(mem_ir_code_4);
              break;
            default:
              ESP_LOGE("save_ir_button", "Invalid button index: %d", buttonIndex);
              return;
          }

          for (char c : hexString) {
              if (c == ' ') {
                  if (hexDigitsInInt > 0) {
                      // Store the current intValue and reset for the next hex value
                      if (arrayIndex < 512) {
                          outputArray[arrayIndex++] = intValue;
                      }
                      intValue = 0;
                      hexDigitsInInt = 0;
                  }
              } else {
                  intValue <<= 4; // Shift left by 4 bits to make space for the next hex digit
                  if (c >= '0' && c <= '9') {
                      intValue |= (c - '0');
                  } else if (c >= 'A' && c <= 'F') {
                      intValue |= (10 + c - 'A');
                  } else if (c >= 'a' && c <= 'f') {
                      intValue |= (10 + c - 'a');
                  }
                  hexDigitsInInt++;
                  
                  if (hexDigitsInInt == 8) {
                      if (arrayIndex < 512) {
                          outputArray[arrayIndex++] = intValue;
                      }
                      intValue = 0;
                      hexDigitsInInt = 0;
                  }
              }
          }

          // Handle the last hex value if there is no trailing space
          if (hexDigitsInInt > 0 && arrayIndex < 512) {
              outputArray[arrayIndex++] = intValue;
          }

          // Store the number of values saved into the first element of the array
          outputArray[0] = arrayIndex - 1; // Minus 1 because arrayIndex starts from 1
          ESP_LOGD("save_ir_button", "Saved %d values for %d", arrayIndex - 1, buttonIndex);
          global_preferences->sync();
  - id: send_ir_code
    parameters:
      buttonIndex: int
    then:
      - if:
          condition:
            lambda: |-
              const std::vector<std::string>& codes = id(ir_memory_button_codes);
              if (codes.size() < buttonIndex) {
                ESP_LOGE("send_ir_code", "Invalid button: %d", buttonIndex + 1);
                return false;
              }

              const std::string& code = codes[buttonIndex];
              if (code.length() == 0) {
                ESP_LOGD("send_ir_code", "Button %d is empty", buttonIndex + 1);
                return false;
              }
              return true;
          then:
            - remote_transmitter.transmit_pronto:
                data: !lambda 'return id(ir_memory_button_codes)[buttonIndex].c_str();'
  - id: set_volume
    parameters:
      volume: float
    then:
      - media_player.volume_set: !lambda 'return volume;' #for some reason, 0.5 is no volume
  - id: check_touchscreen_failure
    then:
      - lambda:
          if (!id(ignore_touchscreen_error) && id(gt911_touchscreen).is_failed() && id(touchscreen_error_counter) < 0) {
            id(touchscreen_error_counter) = 10;
            id(change_app_state).execute(${APP_STATE_TOUCHSCREEN_ERROR});
          }

button:
  - id: reboot
    platform: restart
    name: "Reboot"
  - id: ir_btn_1
    platform: template
    icon: 'mdi:led-off'
    name: "IR Button 1"
    on_press:
      then:
        - script.execute:
            id: send_ir_code
            buttonIndex: 0
  - id: ir_btn_2
    platform: template
    icon: 'mdi:led-off'
    name: "IR Button 2"
    on_press:
      then:
        - script.execute:
            id: send_ir_code
            buttonIndex: 1
  - id: ir_btn_3
    platform: template
    icon: 'mdi:led-off'
    name: "IR Button 3"
    on_press:
      then:
        - script.execute:
            id: send_ir_code
            buttonIndex: 2
  - id: ir_btn_4
    platform: template
    icon: 'mdi:led-off'
    name: "IR Button 4"
    on_press:
      then:
        - script.execute:
            id: send_ir_code
            buttonIndex: 3

binary_sensor:
  # top left hand physical button
  - platform: gpio
    pin:
      number: GPIO0
      mode: INPUT_PULLUP
      inverted: true
    name: Top Left Button
    entity_category: diagnostic
    on_press:
      - if:
          condition:
            - lambda: return id(touchscreen_error_counter) >= 0;
          then:
            - lambda: |-
                id(ignore_touchscreen_error) = true;
                id(touchscreen_error_counter) = -1;
                id(nav_lock) = false;
                id(change_app_state).execute(${APP_STATE_STATUS});
          else:
            - light.toggle: led
  # red circle home button
  - id: home
    platform: gt911
    name: "Home"
    index: 0
    on_press:
      - select.next: mem_va_speaker_mode
      - component.update: s3_box_lcd
  # mute switch
  - id: mute
    platform: gpio
    name: "Mute"
    pin:
      number: GPIO1
      inverted: true
    disabled_by_default: true
    entity_category: diagnostic
    on_state: 
      then:
        - lambda: ESP_LOGD("binary_sensor", "Mute button pressed. Device needs to be rebooted before VA will work."); id(mute_error) = true;
        - component.update: s3_box_lcd
  # radar  
  - id: radar_sensor
    platform: gpio
    pin: GPIO21
    disabled_by_default: false
    name: "Presence Detection"
    device_class: "occupancy"
    on_press:
      then:
        - lambda: id(radar_last_seen) = -1;
        - if:
            condition:
              - lambda: return id(app_state) == ${APP_STATE_SCREEN_SAVER};
            then:
              - script.execute: 
                  id: change_app_state
                  nextState: !lambda 'return id(wake_app_state);'
    on_release:
      then:
        - wait_until: 
          - lambda: return id(ha_time).now().is_valid();
        - lambda: id(radar_last_seen) = id(ha_time).now().timestamp;
  # Touchscreen previous page
  - id: ts_prev_button
    platform: touchscreen
    internal: true
    x_min: 0
    x_max: 70
    y_min: 170
    y_max: 240
    on_press:
      then:
        - if:
            condition: 
              lambda: return !id(nav_lock) && id(app_state) != ${APP_STATE_LOADING};
            then:
              - script.execute:
                  id: change_app_state
                  nextState: !lambda 'int next = (id(app_state) - 1) % ${NUM_PAGES}; return next ? next : (${NUM_PAGES} - 1);'
  # Touchscreen next page
  - id: ts_next_button
    platform: touchscreen
    internal: true
    x_min: 250
    x_max: 320
    y_min: 170
    y_max: 240
    on_press:
      then:
        - if:
            condition: 
              lambda: return !id(nav_lock) && id(app_state) != ${APP_STATE_LOADING};
            then:
              - script.execute:
                  id: change_app_state
                  nextState: !lambda 'int next = (id(app_state) + 1) % ${NUM_PAGES}; return next ? next : 1;'
  # Touchscreen ir memory button 1
  - id: ts_ir_memory_1_button
    platform: touchscreen
    internal: true
    x_min: 40
    x_max: 88
    y_min: 66
    y_max: 114
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 0 && id(enable_ir).state;
            then:
              - lambda: |-
                  id(ir_memory_button_selected) = 0;
                  id(ir_learning_state) = 1;
                  id(nav_lock) = true;
              - component.update: s3_box_lcd
  # Touchscreen ir memory button 2
  - id: ts_ir_memory_2_button
    platform: touchscreen
    internal: true
    x_min: 105
    x_max: 153
    y_min: 66
    y_max: 114
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 0 && id(enable_ir).state;
            then:
              - lambda: |-
                  id(ir_memory_button_selected) = 1;
                  id(ir_learning_state) = 1;
                  id(nav_lock) = true;
              - component.update: s3_box_lcd
  # Touchscreen ir memory button 3
  - id: ts_ir_memory_3_button
    platform: touchscreen
    internal: true
    x_min: 170
    x_max: 223
    y_min: 66
    y_max: 114
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 0 && id(enable_ir).state;
            then:
              - lambda: |-
                  id(ir_memory_button_selected) = 2;
                  id(ir_learning_state) = 1;
                  id(nav_lock) = true;
              - component.update: s3_box_lcd
  # Touchscreen ir memory button 4
  - id: ts_ir_memory_4_button
    platform: touchscreen
    internal: true
    x_min: 235
    x_max: 283
    y_min: 66
    y_max: 114
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 0 && id(enable_ir).state;
            then:
              - lambda: |-
                  id(ir_memory_button_selected) = 3;
                  id(ir_learning_state) = 1;
                  id(nav_lock) = true;
              - component.update: s3_box_lcd
  # Touchscreen ir memory cancel
  - id: ts_ir_memory_cancel_button
    platform: touchscreen
    internal: true
    x_min: 130
    x_max: 190
    y_min: 200
    y_max: 225
    on_press:
      then:
        - if:
            condition: 
              - lambda: return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) != 0;
            then:
              - lambda: |-
                  id(ir_learning_state) = 0;
                  id(ir_learning_step) = 0;
                  id(nav_lock) = false;
                  id(ir_memory_button_selected) = -1;
                  id(ir_memory_recorded_codes).clear();
                  id(ir_memory_recording_codes).clear();
              - component.update: s3_box_lcd
  # Touchscreen ir blast button 1
  - id: ts_ir_blast_1_button
    platform: touchscreen
    internal: true
    x_min: 40
    x_max: 88
    y_min: 66
    y_max: 114
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_IR_BLAST} && id(enable_ir).state;
            then:
              - script.execute: 
                  id: send_ir_code
                  buttonIndex: 0                  
  # Touchscreen volume down
  - id: settings_volume_down
    platform: touchscreen
    internal: true
    x_min: 180
    x_max: 210
    y_min: 90
    y_max: 120
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_SETTINGS};
            then:
              - lambda: |-
                  float volume = id(speaker_media_player).volume;
                  if (volume > 0.5) {
                    volume -= 0.05;
                    if (volume < 0.5)
                      volume = 0.5;
                    id(set_volume).execute(volume);
                  }
              - component.update: s3_box_lcd
  # Touchscreen volume up
  - id: settings_volume_up
    platform: touchscreen
    internal: true
    x_min: 280
    x_max: 310
    y_min: 90
    y_max: 120
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_SETTINGS};
            then:
              - lambda: |-
                  float volume = id(speaker_media_player).volume;
                  if (volume < 1) {
                    volume += 0.05;
                    if (volume > 1)
                      volume = 1;
                    id(set_volume).execute(volume);
                  }
              - component.update: s3_box_lcd
  # Touchscreen sleep down
  - id: settings_sleep_down
    platform: touchscreen
    internal: true
    x_min: 180
    x_max: 210
    y_min: 130
    y_max: 160
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_SETTINGS};
            then:
              - lambda: |-
                  ESP_LOGD("touchscreen", "sleep down");
                  int sleep = id(mem_settings_sleep_delay).state - 5;
                  if (sleep < 1) {
                    sleep = 1;
                  }
                  auto call = id(mem_settings_sleep_delay).make_call();
                  call.set_value(sleep);
                  call.perform();
              - component.update: s3_box_lcd
  # Touchscreen sleep up
  - id: settings_sleep_up
    platform: touchscreen
    internal: true
    x_min: 280
    x_max: 310
    y_min: 130
    y_max: 160
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_SETTINGS};
            then:
              - lambda: |-
                  ESP_LOGD("touchscreen", "sleep up");
                  int sleep = id(mem_settings_sleep_delay).state + 5;
                  auto call = id(mem_settings_sleep_delay).make_call();
                  call.set_value(sleep);
                  call.perform();
              - component.update: s3_box_lcd
  # Touchscreen mute toggle
  - id: settings_mute
    platform: touchscreen
    internal: true
    x_min: 220
    x_max: 270
    y_min: 50
    y_max: 80
    on_press:
      then:
        - if:
            condition: 
              lambda: return id(app_state) == ${APP_STATE_SETTINGS};
            then:
              - select.next: mem_va_speaker_mode
              - component.update: s3_box_lcd              

interval:
  - interval: 1s
    then:
      # IR learning loop
      - if:
          condition:
            - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) != 0;'
          then:
            - lambda: |-
                if (!id(ha_time).now().is_valid()) {
                  ESP_LOGE("interval", "time is invalid");
                }

                switch (id(ir_learning_state)) {
                  // button picked, waiting to turn on
                  case 1:
                    switch (id(ir_learning_step)) { 
                      // wait a second
                      case 0:
                        id(ir_learning_step)++;
                        break;
                      case 1:
                        id(ir_learning_state)++;
                        id(ir_learning_step) = 0;
                        break;
                    }
                    break;

                  // waiting for control signal
                  case 2:
                    switch (id(ir_learning_step)) {
                      case 0:
                        id(ir_memory_last_received) = 0;
                        id(ir_memory_recording_codes).clear();
                        id(ir_learning_step)++;
                        break;
                      case 1:
                        int lastReceived = id(ir_memory_last_received);
                        if (lastReceived > 0 && (id(ha_time).now().timestamp - lastReceived) > 1) {
                          id(ir_learning_step) = 0;

                          std::vector<std::string> codes(id(ir_memory_recording_codes));
                          id(ir_memory_recorded_codes).push_back(codes);
                          if (id(ir_memory_recorded_codes).size() < 2) {
                            // record again
                            id(ir_learning_state) = 1;
                            break;
                          }

                          // # analyze patterns, record code
                          // # ----- begin algorithm --------------------
                          const std::vector<std::string> &vec1 = id(ir_memory_recorded_codes)[0];
                          const std::vector<std::string> &vec2 = id(ir_memory_recorded_codes)[1];
                          std::set<int> set2;
                          for (const auto &str : vec2) {
                              set2.insert(str.length());
                          }

                          int longestCommonStringLength = 0;
                          std::string longestString;

                          // Iterate over the first vector and check for common strings in the set
                          for (const auto &str : vec1) {
                              int str1Length = str.length();
                              if (set2.find(str1Length) != set2.end()) {
                                  if (str1Length > longestCommonStringLength) {
                                      longestCommonStringLength = str1Length;
                                      longestString = str;
                                  }
                              }
                          }
                          // # ----- end algorithm --------------------

                          // only an even number of codes
                          int numSpaces = std::count(longestString.begin(), longestString.end(), ' ');
                          if (longestString.size() > 5 && numSpaces % 2 == 0) {
                            longestString.resize(longestString.size() - 5);
                          }

                          id(ir_memory_button_codes)[id(ir_memory_button_selected)] = longestString;
                          
                          ESP_LOGD("algorithm", longestString.c_str());
                          
                          id(save_ir_button).execute(id(ir_memory_button_selected), longestString);

                          id(nav_lock) = false;
                          id(ir_learning_state) = 0;
                          id(ir_memory_button_selected) = -1;
                          id(ir_memory_recorded_codes).clear();
                          id(ir_memory_recording_codes).clear();
                        }
                        break;
                    }
                }
            - delay: 100ms
            - component.update: s3_box_lcd
      # Screen saver activation
      - if:
          condition: 
            - lambda: |-
                return id(app_state) != ${APP_STATE_LOADING} && 
                  id(radar_last_seen) > 0 && 
                  (id(ha_time).now().timestamp - id(radar_last_seen) >= id(mem_settings_sleep_delay).state);
          then:
            - if:
                condition:
                  - lambda: 'return id(app_state) == ${APP_STATE_SCREEN_SAVER};'
                then:
                  - component.update: s3_box_lcd
                else:
                  - lambda: id(wake_app_state) = id(app_state);
                  - script.execute: 
                      id: change_app_state
                      nextState: ${APP_STATE_SCREEN_SAVER}
      - if:
          condition:
            - lambda: return !id(ignore_touchscreen_error) && id(touchscreen_error_counter) >= 0;
          then:
            - lambda: |-
                id(touchscreen_error_counter)--;
                if (id(touchscreen_error_counter) == 0) {
                  id(reboot).press();
                }
            - component.update: s3_box_lcd

remote_receiver:
  id: ir_rx
  pin: 
    number: 38
    inverted: true
  dump: all
  on_pronto:
    then:
      - if:
          condition:
            - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
          then:
            - lambda: |-
                ESP_LOGD("remote_receiver", x.data.c_str());
                id(ir_memory_recording_codes).push_back(x.data);
            - component.update: s3_box_lcd
  on_abbwelcome:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_aeha:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_byronsx:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_canalsat:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_coolix:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_dish:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_dooya:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_drayton:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_jvc:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_keeloq:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_haier:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_lg:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_magiquest:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_midea:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_nec:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_nexa:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_panasonic:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_pioneer:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_rc5:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_rc6:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_rc_switch:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_roomba:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_samsung:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_samsung36:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_sony:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_toshiba_ac:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_mirage:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == ${APP_STATE_IR_LEARNING} && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  
remote_transmitter:
  id: ir_tx
  pin: 
    number: 39
    inverted: false
  carrier_duty_percent: 50%

display:
  - platform: ili9xxx
    id: s3_box_lcd
    model: S3BOX
    invert_colors: false
    data_rate: 40MHz
    cs_pin: 5
    dc_pin: 4
    reset_pin:
      number: 48
      inverted: true
    update_interval: never
    pages:
      - id: loading_page
        lambda: |-
          it.fill(Color::BLACK);
          it.image((320 / 2), (240 / 2), id(loading_img), ImageAlign::CENTER);

      - id: status_page
        lambda: |-
          int y = 0;
          int x = 15;
          int xinc = 65;

          it.fill(Color::BLACK);
          
          // # print nav buttons
          if (!id(nav_lock)) {
            it.print(5, (240 - 5), id(font_icon_large), TextAlign::BOTTOM_LEFT, "\U000F004F");
            it.print((320 - 5), (240 - 5), id(font_icon_large), TextAlign::BOTTOM_RIGHT, "\U000F0056");
          }

          it.print((320 / 2), 0, id(font_large), yellow, TextAlign::TOP_CENTER, "- Status -");
          y += 42;

          if (network::is_connected()) {
            it.print(x, y, id(font_icon_small), lime, "\U000F16BD");
          } else {
            it.print(x, y, id(font_icon_small), red, "\U000F16BC");
          }
          x += xinc;

          if (api::global_api_server->is_connected()) {
            it.print(x, y, id(font_icon_small), blue, "\U000F07D0");
          } else {
            it.print(x, y, id(font_icon_small), red, "\U000F087B");
          }
          x += xinc;

          x += 3; // oddly spaced icon
          if (id(battery_voltage).has_state ()) {
              if (id(battery_voltage).state <= 2.7) {
                  // Replace battery, less than 10%
                  it.print(x, y, id(font_icon_small), "\U000F10CD");
              } else if (id(battery_percent).state >= 98) {
                  // # mdi-battery
                  it.print(x, y, id(font_icon_small), green, "\U000F0079");
              } else if (id(battery_percent).state >= 90) {
                  // # mdi-battery-90
                  it.print(x, y, id(font_icon_small), green, "\U000F0082");
              } else if (id(battery_percent).state >= 80) {
                  // # mdi-battery-80
                  it.print(x, y, id(font_icon_small), green, "\U000F0081");
              } else if (id(battery_percent).state >= 70) {
                  // # mdi-battery-70
                  it.print(x, y, id(font_icon_small), green, "\U000F0080");
              } else if (id(battery_percent).state >= 60) {
                  // # mdi-battery-60
                  it.print(x, y, id(font_icon_small), green, "\U000F007F");
              } else if (id(battery_percent).state >= 50) {
                  // # mdi-battery-50
                  it.print(x, y, id(font_icon_small), amber, "\U000F007E");
              } else if (id(battery_percent).state >= 40) {
                  // # mdi-battery-40
                  it.print(x, y, id(font_icon_small), amber, "\U000F007D");
              } else if (id(battery_percent).state >= 30) {
                  // # mdi-battery-30
                  it.print(x, y, id(font_icon_small), red, "\U000F007C");
              } else if (id(battery_percent).state >= 20) {
                  // # mdi-battery-20
                  it.print(x, y, id(font_icon_small), red, "\U000F007B");
              } else if (id(battery_percent).state >= 10) {
                  // # mdi-battery-10
                  it.print(x, y, id(font_icon_small), red, "\U000F007A");
              }
          }
          x += xinc;

          if (id(enable_ir).state) {
            it.print(x, y, id(font_icon_small), yellow, "\U000F0330");
          } else {
            it.print(x, y, id(font_icon_small), blue_dark, "\U000F032E");
          }
          x += xinc;
          
          x -= 10; // oddly spaced icon
          it.print(x, y, id(font_icon_small), blue, "\U000F050F");
          it.printf(x + 22, y + 41, id(font_small), black, TextAlign::BOTTOM_CENTER, "%.f", id(s3temp).state);
          it.printf(x + 23, y + 41, id(font_small), black, TextAlign::BOTTOM_CENTER, "%.f", id(s3temp).state);

          // VA status image
          y = (it.get_height() / 2) - 30;
          if (id(mute_error)) {
            it.image((it.get_width() / 2), y, id(error_img), ImageAlign::TOP_CENTER);
            y += 105;
            it.print((it.get_width() / 2), y, id(font_small), red, TextAlign::TOP_CENTER, "HW mute has been pressed.");
            y += 15;
            it.print((it.get_width() / 2), y, id(font_small), red, TextAlign::TOP_CENTER, "Reboot device to restore VA.");
          } else {
            switch (id(va_state)) {
              case ${VA_STATE_NOT_READY}:
                it.image((it.get_width() / 2), y, id(notready_img), ImageAlign::TOP_CENTER);
                break;
              case ${VA_STATE_IDLE}:
                it.image((it.get_width() / 2), y, id(idle_img), ImageAlign::TOP_CENTER);
                break;
              case ${VA_STATE_LISTENING}:
                it.image((it.get_width() / 2), y, id(listening_img), ImageAlign::TOP_CENTER);
                break;
              case ${VA_STATE_THINKING}:
                it.image((it.get_width() / 2), y, id(thinking_img), ImageAlign::TOP_CENTER);
                break;
              case ${VA_STATE_REPLYING}:
                it.image((it.get_width() / 2), y, id(replying_img), ImageAlign::TOP_CENTER);
                break;
              case ${VA_STATE_ERROR}:
                it.image((it.get_width() / 2), y, id(error_img), ImageAlign::TOP_CENTER);
                break;
            }
            
            y += 68;
            if (id(mem_va_speaker_mode).state == "${VA_SPEAKER_MUTE}") {
              it.print((it.get_width() / 2) + 1, y, id(font_icon_tiny), red, TextAlign::TOP_CENTER, "\U000F00AD");
            } else if (id(mem_va_speaker_mode).state == "${VA_SPEAKER_BEEP}") {
              it.print((it.get_width() / 2) + 1, y, id(font_icon_tiny), yellow, TextAlign::TOP_CENTER, "\U000F009C");
            }
          }

      - id: ir_learn_page
        lambda: |-
          int y = 0;
          int x = 15;
          int xinc = 65; // # must be kept in sync with touchscreen buttons
          int btnRadius = 24;

          it.fill(Color::BLACK);
          it.print((it.get_width() / 2), 0, id(font_large), yellow, TextAlign::TOP_CENTER, "- IR Learning -");
          y += 46;

          // # print nav buttons
          if (!id(nav_lock)) {
            it.print(5, (240 - 5), id(font_icon_large), TextAlign::BOTTOM_LEFT, "\U000F004F");
            it.print((320 - 5), (240 - 5), id(font_icon_large), TextAlign::BOTTOM_RIGHT, "\U000F0056");
          }

          if (!id(enable_ir).state) {
            it.print(320 / 2, 240 / 2, id(font_small), white, TextAlign::TOP_CENTER, "The IR must be powered to proceed");
            return;
          }

          if (id(ir_memory_button_selected) == -1) {
            // # recording buttons
            it.print(x, y, id(font_small), white, "IR Memory Buttons:");
            x = 40;
            y = 66; // # must be kept in sync with touchscreen buttons
            it.filled_circle(x + btnRadius, y + btnRadius, btnRadius, (id(ir_memory_button_codes)[0].length() > 0) ? blue_light : blue_dark);
            it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "1");
            x += xinc;
            it.filled_circle(x + btnRadius , y + btnRadius , btnRadius, (id(ir_memory_button_codes)[1].length() > 0) ? blue_light : blue_dark);
            it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "2");
            x += xinc;
            it.filled_circle(x + btnRadius , y + btnRadius , btnRadius, (id(ir_memory_button_codes)[2].length() > 0) ? blue_light : blue_dark);
            it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "3");
            x += xinc;
            it.filled_circle(x + btnRadius , y + btnRadius , btnRadius, (id(ir_memory_button_codes)[3].length() > 0) ? blue_light : blue_dark);
            it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "4");
          } else {
            it.printf(x, y, id(font_small), white, "Recording IR Memory Button %d", id(ir_memory_button_selected) + 1);
            y += 30;
            it.print(x, y, id(font_small), white, "When the icon turns yellow,");
            y += 15;
            it.print(x, y, id(font_small), white, "press the button you want to record.");
            y += 15;
            if (id(ir_learning_state) == 2) {
              it.print(320 / 2, y, id(font_icon_small), yellow, TextAlign::TOP_CENTER, "\U000F0330");
            } else {
              it.print(320 / 2, y, id(font_icon_small), blue_dark, TextAlign::TOP_CENTER, "\U000F032E");
            }
            y += 45;
            
            // # cancel button
            y = 200;
            it.filled_rectangle( (320 / 2) - 30, y, 60, 25, red);
            y += 5;
            it.print(320 / 2, y, id(font_small), white, TextAlign::TOP_CENTER, "Cancel");
          }

      - id: ir_blast_page
        lambda: |-
          it.fill(Color::BLACK);
          it.print((it.get_width() / 2), 0, id(font_large), yellow, TextAlign::TOP_CENTER, "- IR Blast -");

          // # print nav buttons
          if (!id(nav_lock)) {
            it.print(5, (240 - 5), id(font_icon_large), TextAlign::BOTTOM_LEFT, "\U000F004F");
            it.print((320 - 5), (240 - 5), id(font_icon_large), TextAlign::BOTTOM_RIGHT, "\U000F0056");
          }

          if (!id(enable_ir).state) {
            it.print(320 / 2, 240 / 2, id(font_small), white, TextAlign::TOP_CENTER, "The IR must be powered to proceed");
            return;
          }

          int xinc = 65; // # must be kept in sync with touchscreen buttons
          int btnRadius = 24;

          int x = 40;
          int y = 66; // # must be kept in sync with touchscreen buttons
          it.filled_circle(x + btnRadius, y + btnRadius, btnRadius, (id(ir_memory_button_codes)[0].length() > 0) ? blue_light : blue_dark);
          it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "1");
          x += xinc;
          it.filled_circle(x + btnRadius , y + btnRadius , btnRadius, (id(ir_memory_button_codes)[1].length() > 0) ? blue_light : blue_dark);
          it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "2");
          x += xinc;
          it.filled_circle(x + btnRadius , y + btnRadius , btnRadius, (id(ir_memory_button_codes)[2].length() > 0) ? blue_light : blue_dark);
          it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "3");
          x += xinc;
          it.filled_circle(x + btnRadius , y + btnRadius , btnRadius, (id(ir_memory_button_codes)[3].length() > 0) ? blue_light : blue_dark);
          it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "4");

      - id: voice_assistant_page
        lambda: |-
          it.fill(Color::BLACK);
          it.print((it.get_width() / 2), 0, id(font_large), yellow, TextAlign::TOP_CENTER, "- Voice Assistant -");

          // # print nav buttons
          if (!id(nav_lock)) {
            it.print(5, (240 - 5), id(font_icon_large), TextAlign::BOTTOM_LEFT, "\U000F004F");
            it.print((320 - 5), (240 - 5), id(font_icon_large), TextAlign::BOTTOM_RIGHT, "\U000F0056");
          }

          int x = 15;
          int y = 46;

          it.printf(x, y, id(font_small), white, "Wake word engine: %s", id(mem_wake_word_engine_location).state.c_str());

          y += 15;
          it.printf(x, y, id(font_small), white, "Speaker mode: %s", id(mem_va_speaker_mode).state.c_str());

          y += 15;
          std::string stateStr = "Unknown";
          switch (id(va_state)) {
            case ${VA_STATE_IDLE}:
              stateStr = "Idle";
              break;
            case ${VA_STATE_LISTENING}:
              stateStr = "Listening";
              break;
            case ${VA_STATE_THINKING}:
              stateStr = "Thinking";
              break;
            case ${VA_STATE_NOT_READY}:
              stateStr = "Not Ready";
              break;
            case ${VA_STATE_REPLYING}:
              stateStr = "Replying";
              break;
            case ${VA_STATE_ERROR}:
              stateStr = "Error";
              break;
            case ${VA_STATE_MUTED}:
              stateStr = "Muted";
              break;
          }
          it.printf(x, y, id(font_small), white, "Current state: %s", stateStr.c_str());

          if (id(va_request).state.length() > 0) {
            y += 15;
            it.print(x, y, id(font_small), white, "Last request:");
            y += 15;
            it.printf(x, y, id(font_small), white, "%s", id(va_request).state.c_str());
          }

          if (id(va_response).state.length() > 0) {
            y += 15;
            it.print(x, y, id(font_small), white, "Last response:");
            y += 15;
            it.printf(x, y, id(font_small), white, "%s", id(va_response).state.c_str());
          }

          if (id(mute_error)) {
            y += 15;
            it.print(x, y, id(font_small), red, "HW mute error. Reboot device to restore VA.");
          }

      - id: settings_page
        lambda: |-
          it.fill(Color::BLACK);
          it.print((it.get_width() / 2), 0, id(font_large), yellow, TextAlign::TOP_CENTER, "- Settings -");

          // # print nav buttons
          if (!id(nav_lock)) {
            it.print(5, (240 - 5), id(font_icon_large), TextAlign::BOTTOM_LEFT, "\U000F004F");
            it.print((320 - 5), (240 - 5), id(font_icon_large), TextAlign::BOTTOM_RIGHT, "\U000F0056");
          }

          int x = 15;
          int y = 50;

          it.print(x, y, id(font_medium), white, "VA Speaker:");
          if (id(mem_va_speaker_mode).state == "${VA_SPEAKER_SPEECH}") {
            it.print(x + 230, y - 8, id(font_icon_small), lime, TextAlign::TOP_CENTER, "\U000F01F2");
          } else if (id(mem_va_speaker_mode).state == "${VA_SPEAKER_BEEP}") {
            it.print(x + 230, y - 8, id(font_icon_small), yellow, TextAlign::TOP_CENTER, "\U000F009A");
          } else {
            it.print(x + 230, y - 8, id(font_icon_small), red, TextAlign::TOP_CENTER, "\U000F00AD");
          }

          y += 40;
          int volume = (id(speaker_media_player).volume - 0.499) * 200;
          it.print(x, y, id(font_medium), white, TextAlign::TOP_LEFT, "Volume:");
          it.printf(x + 230, y, id(font_medium), white, TextAlign::TOP_CENTER, "%i%%", volume);
          it.print(x + 180, y, id(font_icon_tiny), blue_light, TextAlign::TOP_CENTER, "\U000F0375");
          it.print(x + 280, y, id(font_icon_tiny), blue_light, TextAlign::TOP_CENTER, "\U000F0416");

          y += 40;
          it.print(x, y, id(font_medium), white, TextAlign::TOP_LEFT, "Sleep delay:");
          it.printf(x + 230, y, id(font_medium), white, TextAlign::TOP_CENTER, "%is", (int)id(mem_settings_sleep_delay).state);
          it.print(x + 180, y, id(font_icon_tiny), blue_light, TextAlign::TOP_CENTER, "\U000F0375");
          it.print(x + 280, y, id(font_icon_tiny), blue_light, TextAlign::TOP_CENTER, "\U000F0416");

      - id: screen_saver_page
        lambda: |-
          std::string output;
          switch (id(ha_time).now().timestamp % 10) {
            case 0:
            case 1:
            case 2:
            case 3:
              return;
            case 4:
            case 5:
              output = "Z";
              break;
            case 6:
            case 7:
              output = "ZZ";
              break;
            case 8:
            case 9:
              output = "ZZZ";
              break;
          }
          it.print(320 / 2 - 52, 240 / 2, id(font_extra_large), grey_dark, TextAlign::CENTER_LEFT, output.c_str());

      - id: touchscreen_error_page
        lambda: |-
          it.fill(Color::BLACK);
          
          int x = 15;
          int y = 15;
          
          it.print(x, y, id(font_medium), white, TextAlign::TOP_LEFT, "The touchscreen failed to");
          y += 25;

          it.print(x, y, id(font_medium), white, TextAlign::TOP_LEFT, "setup. The Box will reboot");
          y += 25;

          it.printf(x, y, id(font_medium), white, TextAlign::TOP_LEFT, "in %i seconds.", id(touchscreen_error_counter));
          y += 50;

          it.print(x, y, id(font_medium), white, TextAlign::TOP_LEFT, "To cancel the reboot, push");
          y += 25;

          it.print(x, y, id(font_medium), white, TextAlign::TOP_LEFT, "the top-left button.");
          y += 25;
