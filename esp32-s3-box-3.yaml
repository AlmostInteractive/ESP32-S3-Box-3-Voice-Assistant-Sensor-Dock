substitutions:
  name: esp32-s3box-3
  friendly_name: ESP32 S3 Box 3 Voice Assistant++
  micro_wake_word_model: hey_jarvis  # options: okay_nabu, hey_jarvis, alexa
  allowed_characters: " !#%\"'()+,-./0123456789:;<>?@ABCDEFGHIJKLMNOPQRSTUVWYZ[]_abcdefghijklmnopqrstuvwxyz{|}°²³µ¿ÁÂÄÅÉÖÚßàáâãäåæçèéêëìíîðñòóôõöøùúûüýþāăąćčďĐđēėęěğĮįıļľŁłńňőřśšťũūůűųźŻżŽžơưșțΆΈΌΐΑΒΓΔΕΖΗΘΚΜΝΠΡΣΤΥΦάέήίαβγδεζηθικλμνξοπρςστυφχψωϊόύώАБВГДЕЖЗИКЛМНОПРСТУХЦЧШЪЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюяёђєіїјљњћאבגדהוזחטיכלםמןנסעפץצקרשת،ءآأإئابةتجحخدذرزسشصضطظعغفقكلمنهوىيٹپچڈکگںھہیےংকচতধনফবযরলশষস়ািু্చయలిెొ్ംഅആഇഈഉഎഓകഗങചജഞടഡണതദധനപഫബഭമയരറലളവശസഹാിീുൂെേൈ്ൺൻർൽൾაბგდევზთილმნოპრსტუფქყშჩცძჭხạảấầẩậắặẹẽếềểệỉịọỏốồổỗộớờởợụủứừửữựỳ—、一上不个中为主乾了些亮人任低佔何作供依侧係個側偵充光入全关冇冷几切到制前動區卧厅厨及口另右吊后吗启吸呀咗哪唔問啟嗎嘅嘛器圍在场執場外多大始安定客室家密寵对將小少左已帘常幫幾库度庫廊廚廳开式後恆感態成我戲戶户房所扇手打执把拔换掉控插摄整斯新明是景暗更最會有未本模機檯櫃欄次正氏水沒没洗活派温測源溫漏潮激濕灯為無煙照熱燈燥物狀玄现現瓦用發的盞目着睡私空窗立笛管節簾籬紅線红罐置聚聲脚腦腳臥色节著行衣解設調請謝警设调走路車车运連遊運過道邊部都量鎖锁門閂閉開關门闭除隱離電震霧面音頂題顏颜風风食餅餵가간감갔강개거게겨결경고공과관그금급기길깥꺼껐꼽나난내네놀누는능니다닫담대더데도동됐되된됨둡드든등디때떤뜨라래러렇렌려로료른를리림링마많명몇모무문물뭐바밝방배변보부불블빨뽑사산상색서설성세센션소쇼수스습시신실싱아안않알았애야어얼업없었에여연열옆오온완외왼요운움워원위으은을음의이인일임입있작잠장재전절정제져조족종주줄중줘지직진짐쪽차창천최추출충치침커컴켜켰쿠크키탁탄태탬터텔통트튼티파팬퍼폰표퓨플핑한함해했행혀현화활후휴힘，？"

esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  platformio_options:
    board_build.flash_mode: dio
  on_boot:
    priority: 600
    then:
      - light.turn_on: 
          id: led
          brightness: 100%
      - display.page.show: loading_page
      - component.update: s3_box_lcd
  project:
    name: "VoiceAsstantSensorDock.s3box"
    version: "0.0.1"

esp32:
  board: esp32s3box
  flash_size: 16MB
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: "y"
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"
      CONFIG_AUDIO_BOARD_CUSTOM: "y"
      CONFIG_ESP32_S3_BOX_3_BOARD: "y"
    components:
      - name: esp32_s3_box_3_board
        source: github://jesserockz/esp32-s3-box-3-board@main
        refresh: 0s

external_components:
  - source:
      type: git
      url: https://github.com/gnumpi/esphome_audio
      ref: dev-next
    components: [ adf_pipeline, i2s_audio ]
    refresh: 0s  
 
psram:
  mode: octal
  speed: 80MHz

ota:
  - platform: esphome

logger:
  hardware_uart: USB_SERIAL_JTAG
  level: DEBUG

api:
  id: my_api
  on_client_connected:
    - component.update: s3_box_lcd
  on_client_disconnected:
    - component.update: s3_box_lcd

wifi:
  ap:
    ssid: ${name}
    password: s3box123
  on_connect:
    - script.execute:
        id: initialize
    - script.wait:
        id: initialize
    - script.execute:
        id: change_app_state
        next_state: 3
  on_disconnect:
    - component.update: s3_box_lcd

time:
  - platform: homeassistant
    id: ha_time

output:
  - platform: ledc
    pin: GPIO47
    id: backlight_output

light:
  - platform: monochromatic
    id: led
    name: LCD Backlight
    entity_category: config
    output: backlight_output
    restore_mode: RESTORE_DEFAULT_ON
    default_transition_length: 500ms

spi:
  clk_pin: 7
  mosi_pin: 6

i2c:
  - id: bus_a
    sda: GPIO08
    scl: GPIO18
    scan: false
    sda_pullup_enabled: true
    scl_pullup_enabled: true
    frequency: 100kHz

  - sda: GPIO41
    scl: GPIO40
    scan: false
    sda_pullup_enabled: true
    scl_pullup_enabled: true
    frequency: 50kHz
    id: bus_b

i2s_audio:
  - id: i2s_shared
    i2s_lrclk_pin: GPIO45
    i2s_bclk_pin: GPIO17
    i2s_mclk_pin: GPIO2
    access_mode: duplex

adf_pipeline:
  - platform: i2s_audio
    type: audio_out
    id: adf_i2s_out
    i2s_audio_id: i2s_shared
    i2s_dout_pin: GPIO15
    adf_alc: false
    dac:
      i2c_id: bus_a
      model: es8311
      address: 0x18
      enable_pin: GPIO46
    sample_rate: 16000
    bits_per_sample: 16bit
    fixed_settings: true

  - platform: i2s_audio
    type: audio_in
    id: adf_i2s_in
    i2s_audio_id: i2s_shared
    i2s_din_pin: GPIO16
    pdm: false
    adc:
      i2c_id: bus_a
      model: es7210
      address: 0x40
    sample_rate: 16000
    bits_per_sample: 16bit
    fixed_settings: true

touchscreen:
  platform: gt911
  i2c_id: bus_a
  id: gt911_touchscreen
  interrupt_pin: GPIO3

switch:
  - platform: gpio
    id: enable_ir
    name: "IR Power"
    pin:
      number: GPIO44
      inverted: true
    restore_mode: ALWAYS_ON
    on_turn_off: 
      then:
        - component.update: s3_box_lcd
    on_turn_on: 
      then:
        - component.update: s3_box_lcd
  - platform: template
    id: mute_switch
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

sensor:
  - platform: aht10 
    i2c_id: bus_b
    variant: AHT20
    temperature:
      name: "Temperature"
      id: s3temp
    humidity:
      name: "Humidity"
    update_interval: 60s

  - platform: adc
    pin: GPIO10
    name: "Battery voltage"
    id: battery_voltage
    unit_of_measurement: "V"
    accuracy_decimals: 1
    device_class: "voltage"
    entity_category: "diagnostic"
    disabled_by_default: true
    update_interval: 30s
    attenuation: auto
    filters:
      - multiply: 4.11

  - platform: copy
    id: battery_percent
    source_id: battery_voltage
    name: "Battery level"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    device_class: "battery"
    entity_category: "diagnostic"
    filters:
      - lambda: return (x - 2.7) / (4.2 - 2.7) * 100;
      - clamp:
          min_value: 0
          max_value: 100

font:
  - file: "gfonts://Roboto@500"
    id: font_small
    size: 14
    glyphs: ${allowed_characters}
  - file: "gfonts://Roboto@500"
    id: font_medium
    size: 24
    glyphs: ${allowed_characters}
  - file: "gfonts://Roboto@500"
    id: font_large
    size: 40
    glyphs: ${allowed_characters}
  - file: "https://github.com/BigBobbas/ESP32-S3-Box3-Custom-ESPHome/raw/main/fonts/materialdesignicons-webfont.ttf"
    id: font_icon_small
    size: 45
    glyphs: [
      "\U000F0079",#battery 100%
      "\U000F0082",#battery 90%
      "\U000F0081",#battery 80%
      "\U000F0080",#battery 70%
      "\U000F007F",#battery 60%
      "\U000F007E",#battery 50%
      "\U000F007D",#battery 40%
      "\U000F007C",#battery 30%
      "\U000F007B",#battery 20%
      "\U000F007A",#battery 10%
      "\U000F10CD",#battery warning
      "\U000F050F",#temp sensor
      "\U000F024A",#garden/flower
      "\U000F16BD",#wifi connected
      "\U000F16BC",#wifidisconnected
      "\U000F07D0",#api connected
      "\U000F12A8",#touch button
      "\U000F0EBA",#stats
      "\U000F087B",#api disconnected
      "\U000F0B6C",#car
      "\U000F057E",#speaker on
      "\U000F0581",#speaker off
      "\U000F0493",#settings cog
      "\U000F1C6F",#info
      "\U000F06E8",#light bulb illuminated
      "\U000F0335",#light bulb off
      "\U000F075A",#music
      "\U000F0A19",#toggle off
      "\U000F0521",#toggle on
      "\U000F032E",#led-variant-off
      "\U000F0330",#led-variant-outline
      "\U000F004F",#arrow-left-bold-circle
      "\U000F0056",#arrow-right-bold-circle
      ]
  - file: "https://github.com/BigBobbas/ESP32-S3-Box3-Custom-ESPHome/raw/main/fonts/materialdesignicons-webfont.ttf"
    id: font_icon_large
    size: 65
    glyphs: [
      "\U000F004F",#arrow-left-bold-circle
      "\U000F0056",#arrow-right-bold-circle
      ]

image:
  - file: "https://raw.githubusercontent.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/master/images/error.png"
    id: error_img
    resize: 320x240
    type: RGB24
    use_transparency: true
  - file: "https://raw.githubusercontent.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/master/images/idle.png"
    id: idle_img
    resize: 320x240
    type: RGB24
    use_transparency: true
  - file: "https://raw.githubusercontent.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/master/images/listening.png"
    id: listening_img
    resize: 320x240
    type: RGB24
    use_transparency: true
  - file: "https://raw.githubusercontent.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/master/images/thinking.png"
    id: thinking_img
    resize: 320x240
    type: RGB24
    use_transparency: true
  - file: "https://raw.githubusercontent.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/master/images/replying.png"
    id: replying_img
    resize: 320x240
    type: RGB24
    use_transparency: true
  - file: "https://raw.githubusercontent.com/AlmostInteractive/ESP32-S3-Box-3-Voice-Assistant-Sensor-Dock/master/images/loading.png"
    id: loading_img
    resize: 320x240
    type: RGB24
    use_transparency: true

color:
  - id: green
    hex: '75D15F'
  - id: red
    hex: 'FF3131'
  - id: blue
    hex: '47B7E9'
  - id: blue_drk
    hex: '085296'
  - id: amber
    hex: 'FBAB35'
  - id: lime
    hex: '20FC30'
  - id: pink
    hex: 'D92BBC'
  - id: yellow
    hex: 'FFC000'
  - id: black
    hex: '000000'
  - id: white
    hex: 'ffffff'
  - id: purple
    hex: '73264D'
  - id: light_blue
    hex: 'CFE2F3'

globals:
  # saved to flash
  - id: mem_ir_code_1
    type: int[256]
    restore_value: true
  - id: mem_ir_code_2
    type: int[256]
    restore_value: true
  - id: mem_ir_code_3
    type: int[256]
    restore_value: true
  - id: mem_ir_code_4
    type: int[256]
    restore_value: true
  # saved in ram
  - id: app_state
    type: int
    restore_value: false
    initial_value: '0'    # 0 = Loading, 1 = Status, 2 = IR Learning, 3 = IR Blast
  - id: nav_lock
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: num_pages
    type: int
    restore_value: false
    initial_value: '4'
  - id: ir_memory_button_selected
    type: int
    restore_value: false
    initial_value: '-1'
  - id: ir_memory_button_codes
    type: std::vector<std::string>
    restore_value: false
  - id: ir_learning_state
    type: int
    restore_value: false
    initial_value: '0'    # 0 = pick a button, 1 = button picked, waiting to turn on, 2 = waiting for control signal, 3 = waiting to turn on, 4 = waiting for control signal
  - id: ir_learning_step
    type: int
    restore_value: false
    initial_value: '0'    # 0 = just started, 1 - 2 = recordings to make
  - id: ir_memory_last_received
    type: int
    restore_value: false
    initial_value: '0'
  - id: ir_memory_recording_codes
    type: std::vector<std::string>
    restore_value: false
  - id: ir_memory_recorded_codes
    type: std::vector<std::vector<std::string>>
    restore_value: false

script:
  - id: initialize
    then:
      - lambda: |-
          id(ir_memory_button_codes).resize(4, "");

          int* codeArray;
          int length;
          std::string hexStr;
          char buffer[5];
          int* data;

          for (int i = 0; i < 4; i++) {
            switch (i) {
              case 0:
                codeArray = id(mem_ir_code_1);
                break;
              case 1:
                codeArray = id(mem_ir_code_2);
                break;
              case 2:
                codeArray = id(mem_ir_code_3);
                break;
              case 3:
                codeArray = id(mem_ir_code_4);
                break;
            }
          
            length = codeArray[0];
            ESP_LOGD("initialize", "Found length %d for code %d", length, i + 1);
            if (length <= 0) {
              continue;
            }

            hexStr.clear();
            data = codeArray + 1;
            for (int i = 0; i < length; i++) {
              snprintf(buffer, 5, "%04X", data[i]);
              hexStr += buffer;
              if (i != length - 1) {
                hexStr += " ";
              }
            }

            id(ir_memory_button_codes)[i] = hexStr;
            ESP_LOGD("initialize", "Recovered IR button %d: %s", i + 1, hexStr.c_str());
          }
  - id: change_app_state
    parameters:
      next_state: int
    then:
      - lambda: |-
          id(app_state) = next_state;
          switch (next_state) {
            case 0: // Loading
              id(s3_box_lcd).show_page(id(loading_page));
              break;
            case 1: // Status
              id(s3_box_lcd).show_page(id(status_page));
              break;
            case 2: // IR Learning page
              id(s3_box_lcd).show_page(id(ir_learn_page));
              break;
            case 3: // IR Learning page
              id(s3_box_lcd).show_page(id(ir_blast_page));
              break;
            default:
              ESP_LOGE("change_app_state", "Unknown state: %d", next_state);
          }
      - component.update: s3_box_lcd
  - id: save_ir_button
    parameters:
      buttonIndex: int
      hexString: std::string
    then:
      - lambda: |-
          int arrayIndex = 1; // Start from 1 because the first element will store the count
          int intValue = 0;
          int hexDigitsInInt = 0;
          int* outputArray;
          
          switch (buttonIndex) {
            case 0:
              outputArray = id(mem_ir_code_1);
              break;
            case 1:
              outputArray = id(mem_ir_code_2);
              break;
            case 2:
              outputArray = id(mem_ir_code_3);
              break;
            case 3:
              outputArray = id(mem_ir_code_4);
              break;
            default:
              ESP_LOGE("save_ir_button", "Invalid button index: %d", buttonIndex);
              return;
          }

          for (char c : hexString) {
              if (c == ' ') {
                  if (hexDigitsInInt > 0) {
                      // Store the current intValue and reset for the next hex value
                      if (arrayIndex < 512) {
                          outputArray[arrayIndex++] = intValue;
                      }
                      intValue = 0;
                      hexDigitsInInt = 0;
                  }
              } else {
                  intValue <<= 4; // Shift left by 4 bits to make space for the next hex digit
                  if (c >= '0' && c <= '9') {
                      intValue |= (c - '0');
                  } else if (c >= 'A' && c <= 'F') {
                      intValue |= (10 + c - 'A');
                  } else if (c >= 'a' && c <= 'f') {
                      intValue |= (10 + c - 'a');
                  }
                  hexDigitsInInt++;
                  
                  if (hexDigitsInInt == 8) {
                      if (arrayIndex < 512) {
                          outputArray[arrayIndex++] = intValue;
                      }
                      intValue = 0;
                      hexDigitsInInt = 0;
                  }
              }
          }

          // Handle the last hex value if there is no trailing space
          if (hexDigitsInInt > 0 && arrayIndex < 512) {
              outputArray[arrayIndex++] = intValue;
          }

          // Store the number of values saved into the first element of the array
          outputArray[0] = arrayIndex - 1; // Minus 1 because arrayIndex starts from 1
          ESP_LOGD("save_ir_button", "Saved %d values for %d", arrayIndex - 1, buttonIndex);
          global_preferences->sync();
  - id: send_ir_code
    parameters:
      buttonIndex: int
    then:
      - if:
          condition:
            lambda: |-
              const std::vector<std::string>& codes = id(ir_memory_button_codes);
              if (codes.size() < buttonIndex) {
                ESP_LOGE("send_ir_code", "Invalid button: %d", buttonIndex + 1);
                return false;
              }

              const std::string& code = codes[buttonIndex];
              if (code.length() == 0) {
                ESP_LOGD("send_ir_code", "Button %d is empty", buttonIndex + 1);
                return false;
              }
              return true;
          then:
            - remote_transmitter.transmit_pronto:
                data: !lambda "return id(ir_memory_button_codes)[buttonIndex].c_str();"                

button:
  - platform: restart
    id: reboot
    name: "Reboot"
  - platform: template
    id: ir_btn_1
    name: "IR Button 1"
    on_press:
      then:
        - script.execute:
            id: send_ir_code
            buttonIndex: 0
  - platform: template
    id: ir_btn_2
    name: "IR Button 2"
    on_press:
      then:
        - script.execute:
            id: send_ir_code
            buttonIndex: 1
  - platform: template
    id: ir_btn_3
    name: "IR Button 3"
    on_press:
      then:
        - script.execute:
            id: send_ir_code
            buttonIndex: 2
  - platform: template
    id: ir_btn_4
    name: "IR Button 4"
    on_press:
      then:
        - script.execute:
            id: send_ir_code
            buttonIndex: 3

binary_sensor:
  # top left hand physical button
  - platform: gpio
    pin:
      number: GPIO0
      mode: INPUT_PULLUP
      inverted: true
    name: Top Left Button
    entity_category: diagnostic
    on_press:
      - light.toggle: led
  # red circle home button
  - platform: gt911
    name: "Home"
    index: 0
    on_press:
      - logger.log:
          format: "Red circle pressed"
  # Touchscreen previous page
  - platform: touchscreen
    id: ts_prev_button
    internal: true
    x_min: 0
    x_max: 70
    y_min: 170
    y_max: 240
    on_press:
      then:
        - if:
            condition: 
              lambda: 'return !id(nav_lock) && id(app_state) != 0;'
            then:
              - script.execute:
                  id: change_app_state
                  next_state: !lambda 'int next = (id(app_state) - 1) % id(num_pages); return next ? next : 2;'
  # Touchscreen next page
  - platform: touchscreen
    id: ts_next_button
    internal: true
    x_min: 250
    x_max: 320
    y_min: 170
    y_max: 240
    on_press:
      then:
        - if:
            condition: 
              lambda: 'return !id(nav_lock) && id(app_state) != 0;'
            then:
              - script.execute:
                  id: change_app_state
                  next_state: !lambda 'int next = (id(app_state) + 1) % id(num_pages); return next ? next : 1;'
  # Touchscreen ir memory button 1
  - platform: touchscreen
    id: ts_ir_memory_1_button
    internal: true
    x_min: 40
    x_max: 88
    y_min: 66
    y_max: 114
    on_press:
      then:
        - if:
            condition: 
              lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 0 && id(enable_ir).state;'
            then:
              - lambda: |-
                  id(ir_memory_button_selected) = 0;
                  id(ir_learning_state) = 1;
                  id(nav_lock) = true;
              - component.update: s3_box_lcd
  # Touchscreen ir memory button 2
  - platform: touchscreen
    id: ts_ir_memory_2_button
    internal: true
    x_min: 105
    x_max: 153
    y_min: 66
    y_max: 114
    on_press:
      then:
        - if:
            condition: 
              lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 0 && id(enable_ir).state;'
            then:
              - lambda: |-
                  id(ir_memory_button_selected) = 1;
                  id(ir_learning_state) = 1;
                  id(nav_lock) = true;
              - component.update: s3_box_lcd
  # Touchscreen ir memory button 3
  - platform: touchscreen
    id: ts_ir_memory_3_button
    internal: true
    x_min: 170
    x_max: 223
    y_min: 66
    y_max: 114
    on_press:
      then:
        - if:
            condition: 
              lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 0 && id(enable_ir).state;'
            then:
              - lambda: |-
                  id(ir_memory_button_selected) = 2;
                  id(ir_learning_state) = 1;
                  id(nav_lock) = true;
              - component.update: s3_box_lcd
  # Touchscreen ir memory button 4
  - platform: touchscreen
    id: ts_ir_memory_4_button
    internal: true
    x_min: 235
    x_max: 283
    y_min: 66
    y_max: 114
    on_press:
      then:
        - if:
            condition: 
              lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 0 && id(enable_ir).state;'
            then:
              - lambda: |-
                  id(ir_memory_button_selected) = 3;
                  id(ir_learning_state) = 1;
                  id(nav_lock) = true;
              - component.update: s3_box_lcd
  # Touchscreen ir memory cancel
  - platform: touchscreen
    id: ts_ir_memory_cancel_button
    internal: true
    x_min: 130
    x_max: 190
    y_min: 200
    y_max: 225
    on_press:
      then:
        - if:
            condition: 
              - lambda: 'return id(app_state) == 2 && id(ir_learning_state) != 0;'
            then:
              - lambda: |-
                  id(ir_learning_state) = 0;
                  id(ir_learning_step) = 0;
                  id(nav_lock) = false;
                  id(ir_memory_button_selected) = -1;
                  id(ir_memory_recorded_codes).clear();
                  id(ir_memory_recording_codes).clear();
              - component.update: s3_box_lcd
  # Touchscreen ir blast button 1
  - platform: touchscreen
    id: ts_ir_blast_1_button
    internal: true
    x_min: 40
    x_max: 88
    y_min: 66
    y_max: 114
    on_press:
      then:
        - if:
            condition: 
              lambda: 'return id(app_state) == 3 && id(enable_ir).state;'
            then:
              - script.execute: 
                  id: send_ir_code
                  buttonIndex: 0                  

interval:
  - interval: 1s
    then:
      - if:
          condition:
            - lambda: 'return id(app_state) == 2 && id(ir_learning_state) != 0;'
          then:
            - lambda: |-
                if (!id(ha_time).now().is_valid()) {
                  ESP_LOGE("interval", "time is invalid");
                }

                switch (id(ir_learning_state)) {
                  // button picked, waiting to turn on
                  case 1:
                    switch (id(ir_learning_step)) { 
                      // wait a second
                      case 0:
                        id(ir_learning_step)++;
                        break;
                      case 1:
                        id(ir_learning_state)++;
                        id(ir_learning_step) = 0;
                        break;
                    }
                    break;

                  // waiting for control signal
                  case 2:
                    switch (id(ir_learning_step)) {
                      case 0:
                        id(ir_memory_last_received) = 0;
                        id(ir_memory_recording_codes).clear();
                        id(ir_learning_step)++;
                        break;
                      case 1:
                        int lastReceived = id(ir_memory_last_received);
                        if (lastReceived > 0 && (id(ha_time).now().timestamp - lastReceived) > 1) {
                          id(ir_learning_step) = 0;

                          std::vector<std::string> codes(id(ir_memory_recording_codes));
                          id(ir_memory_recorded_codes).push_back(codes);
                          if (id(ir_memory_recorded_codes).size() < 2) {
                            // record again
                            id(ir_learning_state) = 1;
                            break;
                          }

                          // # analyze patterns, record code
                          // # ----- begin algorithm --------------------
                          const std::vector<std::string> &vec1 = id(ir_memory_recorded_codes)[0];
                          const std::vector<std::string> &vec2 = id(ir_memory_recorded_codes)[1];
                          std::set<int> set2;
                          for (const auto &str : vec2) {
                              set2.insert(str.length());
                          }

                          int longestCommonStringLength = 0;
                          std::string longestString;

                          // Iterate over the first vector and check for common strings in the set
                          for (const auto &str : vec1) {
                              int str1Length = str.length();
                              if (set2.find(str1Length) != set2.end()) {
                                  if (str1Length > longestCommonStringLength) {
                                      longestCommonStringLength = str1Length;
                                      longestString = str;
                                  }
                              }
                          }
                          // # ----- end algorithm --------------------

                          // only an even number of codes
                          int numSpaces = std::count(longestString.begin(), longestString.end(), ' ');
                          if (longestString.size() > 5 && numSpaces % 2 == 0) {
                            longestString.resize(longestString.size() - 5);
                          }

                          id(ir_memory_button_codes)[id(ir_memory_button_selected)] = longestString;
                          
                          ESP_LOGD("algorithm", longestString.c_str());
                          
                          id(save_ir_button).execute(id(ir_memory_button_selected), longestString);

                          id(nav_lock) = false;
                          id(ir_learning_state) = 0;
                          id(ir_memory_button_selected) = -1;
                          id(ir_memory_recorded_codes).clear();
                          id(ir_memory_recording_codes).clear();
                        }
                        break;
                    }
                }
            - delay: 100ms
            - component.update: s3_box_lcd

remote_receiver:
  id: ir_rx
  pin: 
    number: 38
    inverted: true
  dump: all
  rmt_channel: 4
  memory_blocks: 4
  on_pronto:
    then:
      - if:
          condition:
            - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
          then:
            - lambda: |-
                ESP_LOGD("remote_receiver", x.data.c_str());
                id(ir_memory_recording_codes).push_back(x.data);
            - component.update: s3_box_lcd
  on_abbwelcome:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_aeha:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_byronsx:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_canalsat:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_coolix:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_dish:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_dooya:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_drayton:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_jvc:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_keeloq:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_haier:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_lg:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_magiquest:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_midea:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_nec:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_nexa:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_panasonic:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_pioneer:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_rc5:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_rc6:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_rc_switch:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_roomba:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_samsung:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_samsung36:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_sony:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_toshiba_ac:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  on_mirage:
    then:
    - if:
        condition:
          - lambda: 'return id(app_state) == 2 && id(ir_learning_state) == 2;'
        then:
          - lambda: 'id(ir_memory_last_received) = id(ha_time).now().timestamp;'
  
remote_transmitter:
  id: ir_tx
  pin: 
    number: 39
    inverted: false
  carrier_duty_percent: 50%
  rmt_channel: 0

display:
  - platform: ili9xxx
    id: s3_box_lcd
    model: S3BOX
    data_rate: 40MHz
    cs_pin: 5
    dc_pin: 4
    reset_pin:
      number: 48
      inverted: true
    update_interval: never
    pages:
      - id: loading_page
        lambda: |-
          it.fill(Color::BLACK);
          it.image((320 / 2), (240 / 2), id(loading_img), ImageAlign::CENTER);

      - id: status_page
        lambda: |-
          int y = 0;
          int x = 15;
          int xinc = 65;

          it.fill(Color::BLACK);
          
          // # print nav buttons
          if (!id(nav_lock)) {
            it.print(5, (240 - 5), id(font_icon_large), TextAlign::BOTTOM_LEFT, "\U000F004F");
            it.print((320 - 5), (240 - 5), id(font_icon_large), TextAlign::BOTTOM_RIGHT, "\U000F0056");
          }

          it.print((320 / 2), 0, id(font_large), yellow, TextAlign::TOP_CENTER, "- Status -");
          y += 42;

          if (api::global_api_server->is_connected()) {
            it.print(x, y, id(font_icon_small), blue, "\U000F07D0");
          } else {
            it.print(x, y, id(font_icon_small), red, "\U000F087B");
          }
          x += xinc;

          if (network::is_connected()) {
            it.print(x, y, id(font_icon_small), lime, "\U000F16BD");
          } else {
            it.print(x, y, id(font_icon_small), red, "\U000F16BC");
          }
          x += xinc;

          x += 3; // oddly spaced icon
          if (id(battery_voltage).has_state ()) {
              if (id(battery_voltage).state <= 2.7) {
                  // Replace battery, less than 10%
                  it.print(x, y, id(font_icon_small), "\U000F10CD");
              } else if (id(battery_percent).state >= 98) {
                  // # mdi-battery
                  it.print(x, y, id(font_icon_small), green, "\U000F0079");
              } else if (id(battery_percent).state >= 90) {
                  // # mdi-battery-90
                  it.print(x, y, id(font_icon_small), green, "\U000F0082");
              } else if (id(battery_percent).state >= 80) {
                  // # mdi-battery-80
                  it.print(x, y, id(font_icon_small), green, "\U000F0081");
              } else if (id(battery_percent).state >= 70) {
                  // # mdi-battery-70
                  it.print(x, y, id(font_icon_small), green, "\U000F0080");
              } else if (id(battery_percent).state >= 60) {
                  // # mdi-battery-60
                  it.print(x, y, id(font_icon_small), green, "\U000F007F");
              } else if (id(battery_percent).state >= 50) {
                  // # mdi-battery-50
                  it.print(x, y, id(font_icon_small), amber, "\U000F007E");
              } else if (id(battery_percent).state >= 40) {
                  // # mdi-battery-40
                  it.print(x, y, id(font_icon_small), amber, "\U000F007D");
              } else if (id(battery_percent).state >= 30) {
                  // # mdi-battery-30
                  it.print(x, y, id(font_icon_small), red, "\U000F007C");
              } else if (id(battery_percent).state >= 20) {
                  // # mdi-battery-20
                  it.print(x, y, id(font_icon_small), red, "\U000F007B");
              } else if (id(battery_percent).state >= 10) {
                  // # mdi-battery-10
                  it.print(x, y, id(font_icon_small), red, "\U000F007A");
              }
          }
          x += xinc;

          if (id(enable_ir).state) {
            it.print(x, y, id(font_icon_small), amber, "\U000F0330");
          } else {
            it.print(x, y, id(font_icon_small), blue_drk, "\U000F032E");
          }
          x += xinc;
          
          x -= 10; // oddly spaced icon
          it.print(x, y, id(font_icon_small), blue, "\U000F050F");
          it.printf(x + 22, y + 41, id(font_small), black, TextAlign::BOTTOM_CENTER, "%.f", id(s3temp).state);
          it.printf(x + 23, y + 41, id(font_small), black, TextAlign::BOTTOM_CENTER, "%.f", id(s3temp).state);

      - id: ir_learn_page
        lambda: |-
          int y = 0;
          int x = 15;
          int xinc = 65; // # must be kept in sync with touchscreen buttons
          int btnRadius = 24;

          it.fill(Color::BLACK);
          it.print((it.get_width() / 2), 0, id(font_large), yellow, TextAlign::TOP_CENTER, "- IR Learning -");
          y += 46;

          // # print nav buttons
          if (!id(nav_lock)) {
            it.print(5, (240 - 5), id(font_icon_large), TextAlign::BOTTOM_LEFT, "\U000F004F");
            it.print((320 - 5), (240 - 5), id(font_icon_large), TextAlign::BOTTOM_RIGHT, "\U000F0056");
          }

          if (!id(enable_ir).state) {
            it.print(320 / 2, 240 / 2, id(font_small), white, TextAlign::TOP_CENTER, "The IR must be powered to proceed");
            return;
          }

          if (id(ir_memory_button_selected) == -1) {
            // # recording buttons
            it.print(x, y, id(font_small), white, "IR Memory Buttons:");
            x = 40;
            y = 66; // # must be kept in sync with touchscreen buttons
            it.filled_circle(x + btnRadius, y + btnRadius, btnRadius, (id(ir_memory_button_codes)[0].length() > 0) ? light_blue : blue_drk);
            it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "1");
            x += xinc;
            it.filled_circle(x + btnRadius , y + btnRadius , btnRadius, (id(ir_memory_button_codes)[1].length() > 0) ? light_blue : blue_drk);
            it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "2");
            x += xinc;
            it.filled_circle(x + btnRadius , y + btnRadius , btnRadius, (id(ir_memory_button_codes)[2].length() > 0) ? light_blue : blue_drk);
            it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "3");
            x += xinc;
            it.filled_circle(x + btnRadius , y + btnRadius , btnRadius, (id(ir_memory_button_codes)[3].length() > 0) ? light_blue : blue_drk);
            it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "4");
          } else {
            it.printf(x, y, id(font_small), white, "Recording IR Memory Button %d", id(ir_memory_button_selected) + 1);
            y += 30;
            it.print(x, y, id(font_small), white, "When the icon turns yellow,");
            y += 15;
            it.print(x, y, id(font_small), white, "press the button you want to record.");
            y += 15;
            if (id(enable_ir).state) {
              it.print(320 / 2, y, id(font_icon_small), amber, TextAlign::TOP_CENTER, "\U000F0330");
            } else {
              it.print(320 / 2, y, id(font_icon_small), blue_drk, TextAlign::TOP_CENTER, "\U000F032E");
            }
            y += 45;
            it.printf(320 / 2, y, id(font_small), white, TextAlign::TOP_CENTER, "%d", id(ir_learning_state));
            
            // # cancel button
            y = 200;
            it.filled_rectangle( (320 / 2) - 30, y, 60, 25, red);
            y += 5;
            it.print(320 / 2, y, id(font_small), white, TextAlign::TOP_CENTER, "Cancel");
          }

      - id: ir_blast_page
        lambda: |-
          it.fill(Color::BLACK);
          it.print((it.get_width() / 2), 0, id(font_large), yellow, TextAlign::TOP_CENTER, "- IR Blast -");

          // # print nav buttons
          if (!id(nav_lock)) {
            it.print(5, (240 - 5), id(font_icon_large), TextAlign::BOTTOM_LEFT, "\U000F004F");
            it.print((320 - 5), (240 - 5), id(font_icon_large), TextAlign::BOTTOM_RIGHT, "\U000F0056");
          }

          if (!id(enable_ir).state) {
            it.print(320 / 2, 240 / 2, id(font_small), white, TextAlign::TOP_CENTER, "The IR must be powered to proceed");
            return;
          }

          int xinc = 65; // # must be kept in sync with touchscreen buttons
          int btnRadius = 24;

          int x = 40;
          int y = 66; // # must be kept in sync with touchscreen buttons
          it.filled_circle(x + btnRadius, y + btnRadius, btnRadius, (id(ir_memory_button_codes)[0].length() > 0) ? light_blue : blue_drk);
          it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "1");
          x += xinc;
          it.filled_circle(x + btnRadius , y + btnRadius , btnRadius, (id(ir_memory_button_codes)[1].length() > 0) ? light_blue : blue_drk);
          it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "2");
          x += xinc;
          it.filled_circle(x + btnRadius , y + btnRadius , btnRadius, (id(ir_memory_button_codes)[2].length() > 0) ? light_blue : blue_drk);
          it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "3");
          x += xinc;
          it.filled_circle(x + btnRadius , y + btnRadius , btnRadius, (id(ir_memory_button_codes)[3].length() > 0) ? light_blue : blue_drk);
          it.print(x + btnRadius , y + btnRadius , id(font_large), white, TextAlign::CENTER, "4");

